{"version":3,"sources":["webpack:///./src/scss/templates/src/scss/templates/cases.scss","webpack:///./src/scss/templates/cases.scss","webpack:///./src/scss/templates/src/scss/tools/mq.scss"],"names":[],"mappings":"AAGA,YACE,aACA,eACA,kBCMD,cDFC,qBACA,kBACA,WEoKE,wBFvKJ,cAMI,UCQD,CCyJC,wBFvKJ,cAUI,qBCUD,CACF,sBDNC,cACA,gBACA,mBCUD,gBDNC,iBACA,oBCUD,4BDNC,yBACA","file":"css/templates/cases.css","sourcesContent":["$ENV: production;\n@import \"../includes\";\n\n.cases-grid {\n  display: flex;\n  flex-wrap: wrap;\n  margin-left: -3rem;\n}\n\n.cases-grid > * {\n  margin-bottom: 4.5rem;\n  padding-left: 3rem;\n  width: 100%;\n\n  @include mq(from s) {\n    width: 50%;\n  }\n\n  @include mq(from m) {\n    width: percentage(1 / 3);\n  }\n}\n\n.cases-grid .h5::after {\n  color: $color-yellow;\n  content: \"âº\";\n  margin-left: .25rem;\n}\n\n.cases-grid .h6 {\n  letter-spacing: 0;\n  text-transform: none;\n}\n\n.cases-grid .screenshot img {\n  border: 1px solid $color-background;\n  padding: 4px;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/scss/templates/src/scss/templates/cases.scss","@charset \"UTF-8\";\n/* stylelint-disable block-closing-brace-empty-line-before, at-rule-empty-line-before */\n/* stylelint-disable at-rule-empty-line-before */\n/* stylelint-disable at-rule-empty-line-before */\n.cases-grid {\n  display: flex;\n  flex-wrap: wrap;\n  margin-left: -3rem;\n}\n\n.cases-grid > * {\n  margin-bottom: 4.5rem;\n  padding-left: 3rem;\n  width: 100%;\n}\n\n@media (min-width: 38em) {\n  .cases-grid > * {\n    width: 50%;\n  }\n}\n\n@media (min-width: 56em) {\n  .cases-grid > * {\n    width: 33.3333333333%;\n  }\n}\n\n.cases-grid .h5::after {\n  color: #cca000;\n  content: \"›\";\n  margin-left: .25rem;\n}\n\n.cases-grid .h6 {\n  letter-spacing: 0;\n  text-transform: none;\n}\n\n.cases-grid .screenshot img {\n  border: 1px solid #efefef;\n  padding: 4px;\n}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9zY3NzL3RlbXBsYXRlcy9jYXNlcy5zY3NzIiwic3JjL3Njc3MvaW5jbHVkZXMuc2NzcyIsInNyYy9zY3NzL3ZhcmlhYmxlcy5zY3NzIiwic3JjL3Njc3MvdG9vbHMvbXEuc2NzcyIsInNyYy9zY3NzL3Rvb2xzL2Z1bmN0aW9ucy5zY3NzIiwic3JjL3Njc3MvdG9vbHMvbWl4aW5zLnNjc3MiXSwic291cmNlc0NvbnRlbnQiOlsiJEVOVjogcHJvZHVjdGlvbjtcbkBpbXBvcnQgXCIuLi9pbmNsdWRlc1wiO1xuXG4uY2FzZXMtZ3JpZCB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtd3JhcDogd3JhcDtcbiAgbWFyZ2luLWxlZnQ6IC0zcmVtO1xufVxuXG4uY2FzZXMtZ3JpZCA+ICoge1xuICBtYXJnaW4tYm90dG9tOiA0LjVyZW07XG4gIHBhZGRpbmctbGVmdDogM3JlbTtcbiAgd2lkdGg6IDEwMCU7XG5cbiAgQGluY2x1ZGUgbXEoZnJvbSBzKSB7XG4gICAgd2lkdGg6IDUwJTtcbiAgfVxuXG4gIEBpbmNsdWRlIG1xKGZyb20gbSkge1xuICAgIHdpZHRoOiBwZXJjZW50YWdlKDEgLyAzKTtcbiAgfVxufVxuXG4uY2FzZXMtZ3JpZCAuaDU6OmFmdGVyIHtcbiAgY29sb3I6ICRjb2xvci15ZWxsb3c7XG4gIGNvbnRlbnQ6IFwi4oC6XCI7XG4gIG1hcmdpbi1sZWZ0OiAuMjVyZW07XG59XG5cbi5jYXNlcy1ncmlkIC5oNiB7XG4gIGxldHRlci1zcGFjaW5nOiAwO1xuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcbn1cblxuLmNhc2VzLWdyaWQgLnNjcmVlbnNob3QgaW1nIHtcbiAgYm9yZGVyOiAxcHggc29saWQgJGNvbG9yLWJhY2tncm91bmQ7XG4gIHBhZGRpbmc6IDRweDtcbn1cbiIsIi8vIFdpbGwgYmUgb3ZlcnJpZGRlbiBmcm9tIFdlYnBhY2sgYW5kIGNhblxuLy8gZWl0aGVyIGJlICdkZXZlbG9wbWVudCcgb3IgJ3Byb2R1Y3Rpb24nLlxuJEVOVjogZGV2ZWxvcG1lbnQgIWRlZmF1bHQ7XG5cbkBpbXBvcnQgXCJ2YXJpYWJsZXNcIjtcbkBpbXBvcnQgXCJ0b29scy9tcVwiO1xuQGltcG9ydCBcInRvb2xzL2Z1bmN0aW9uc1wiO1xuQGltcG9ydCBcInRvb2xzL21peGluc1wiO1xuIiwiLy8gPT09PT0gIFR5cG9ncmFwaHkgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gLy9cblxuJGZvbnQtc2FuczogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcIlNlZ29lIFVJXCIsIFJvYm90bywgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZiwgXCJBcHBsZSBDb2xvciBFbW9qaVwiLCBcIlNlZ29lIFVJIEVtb2ppXCIsIFwiU2Vnb2UgVUkgU3ltYm9sXCI7XG4kZm9udC1tb25vOiBcIlNGTW9uby1SZWd1bGFyXCIsIENvbnNvbGFzLCBcIkxpYmVyYXRpb24gTW9ub1wiLCBNZW5sbywgQ291cmllciwgbW9ub3NwYWNlO1xuXG4kZm9udC1zaXplLW1vbm86ICAgMTZweDtcbiRsaW5lLWhlaWdodC1tb25vOiAyNHB4O1xuJGZvbnQtc2l6ZS1jb2RlOiAgIDE0cHg7XG4kbGluZS1oZWlnaHQtY29kZTogMjRweDtcblxuJGZvbnQtd2VpZ2h0LXJlZ3VsYXI6ICAgICAgNDAwO1xuJGZvbnQtd2VpZ2h0LW1lZGl1bTogICAgICAgNzAwO1xuJGZvbnQtd2VpZ2h0LWJvbGQ6ICAgICAgICAgNzAwO1xuJGZvbnQtd2VpZ2h0LWJsYWNrOiAgICAgICAgNzAwO1xuXG4vLyA9PT09PSAgQ29sb3JzICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAvL1xuXG4vLyAtLS0tLSAgUHJpbWFyeSBQYWxldHRlICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4kY29sb3Itd2hpdGU6ICAgICAgICAgICAgICAjZmZmO1xuJGNvbG9yLWJhY2tncm91bmQ6ICAgICAgICAgI2VmZWZlZjtcbiRjb2xvci1tdXRlZDogICAgICAgICAgICAgICM3Nzc7XG4kY29sb3ItbGlnaHQtZ3JheTogICAgICAgICAjY2VkMmQ3O1xuJGNvbG9yLWFudGhyYWNpdGU6ICAgICAgICAgIzNjNDM1MDtcbiRjb2xvci1kYXJrLWdyYXk6ICAgICAgICAgICMyMzI1Mjk7XG4kY29sb3ItYmxhY2s6ICAgICAgICAgICAgICAjMDAwO1xuXG4kY29sb3ItaW5zZXQ6ICNlYmViZWI7XG4kY29sb3ItYm9yZGVyOiAjY2NjO1xuXG4kY29sb3Ita2lyYnktYmx1ZTogICAgICAgICAjNDI3MWFlO1xuJGNvbG9yLWtpcmJ5LWJsdWUtYWx0OiAgICAgIzU4OTBkODtcbiRjb2xvci1mb2N1cy1vdXRsaW5lOiAgICAgICAgcmdiYSgkY29sb3Ita2lyYnktYmx1ZSwgLjYpO1xuJGNvbG9yLWZvY3VzLW91dGxpbmUtYWx0OiAgICByZ2JhKCRjb2xvci1raXJieS1ibHVlLWFsdCwgLjgpO1xuXG4vLyAtLS0tLSAgQ29sb3JzIGZvciBsaWdodCBiYWNrZ3JvdW5kcyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4kY29sb3ItcmVkOiAgICAgICAgICAgICAgICBoc2woMCwgNzElLCA1NSUpO1xuJGNvbG9yLW9yYW5nZTogICAgICAgICAgICAgaHNsKDI5LCA5MSUsIDU0JSk7XG4kY29sb3IteWVsbG93OiAgICAgICAgICAgICBoc2woNDcsIDEwMCUsIDQwJSk7XG4kY29sb3ItZ3JlZW46ICAgICAgICAgICAgICBoc2woNjUsIDcxJSwgMzYlKTtcbiRjb2xvci1hcXVhOiAgICAgICAgICAgICAgIGhzbCgxODMsIDQ0JSwgNDAlKTtcbiRjb2xvci1ibHVlOiAgICAgICAgICAgICAgIGhzbCgyMTQsIDQ1JSwgNDclKTtcbiRjb2xvci1wdXJwbGU6ICAgICAgICAgICAgIGhzbCgyODUsIDQ0JSwgNTAlKTtcblxuLy8gLS0tLS0gIENvbG9ycyBmb3IgZGFyayBiYWNrZ3JvdW5kcyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuJGNvbG9yLXN5bnRheDogICAgICAgICAgICAgJGNvbG9yLWJhY2tncm91bmQ7XG4kY29sb3Itc3ludGF4LWNvbW1lbnQ6ICAgICAjYTlhYWFkO1xuJGNvbG9yLXN5bnRheC1saWdodC1ncmF5OiAgI2NhY2JkMTtcbiRjb2xvci1zeW50YXgtd2hpdGU6ICAgICAgICNjNWM5YzY7XG5cbiRjb2xvci1zeW50YXgtcmVkOiAgICAgICAgICNkMTY0NjQ7XG4kY29sb3Itc3ludGF4LW9yYW5nZTogICAgICAjZGU5MzVmO1xuJGNvbG9yLXN5bnRheC15ZWxsb3c6ICAgICAgI2YwYzY3NDtcbiRjb2xvci1zeW50YXgtZ3JlZW46ICAgICAgICNhN2JkNjg7XG4kY29sb3Itc3ludGF4LWFxdWE6ICAgICAgICAjOGFiZWI3O1xuJGNvbG9yLXN5bnRheC1ibHVlOiAgICAgICAgIzdlOWFiZjtcbiRjb2xvci1zeW50YXgtcHVycGxlOiAgICAgICNiMjk0YmI7XG5cbi8vIC0tLS0tICBEaXZlcnRlZCBjb2xvcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiRjb2xvci1pbmZvLWJhY2tncm91bmQ6ICAgIG1peCgkY29sb3ItYmx1ZSwgJGNvbG9yLWJhY2tncm91bmQsIDEyJSk7XG4kY29sb3Itd2FybmluZy1iYWNrZ3JvdW5kOiBtaXgoJGNvbG9yLXllbGxvdywgJGNvbG9yLWJhY2tncm91bmQsIDEyJSk7XG5cbi8vID09PT09ICBTdHlsZSAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IC8vXG5cbiRib3JkZXItcmFkaXVzOiAxcHg7XG4kYm9yZGVyLXJhZGl1cy1saW5rLWJhY2twbGFuZTogNHB4O1xuJHNoYWRvdzogMCAycHggMTBweCByZ2JhKCMwMDAsIC4yKTtcbiRlbGVtZW50LXNwYWNpbmc6IDEuNWVtOyAvLyBzaG91bGQgYmUgZXF1YWwgdG8gbGluZS1oZWlnaHRcblxuLy8gPT09PT0gIEJyZWFrcG9pbnRzICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gLy9cblxuJG1xLWJyZWFrcG9pbnRzOiAoXG4gIChcIlwiIDApXG4gIChzIDYwOHB4KVxuICAobSA4OTZweClcbiAgKGwgMTIwMHB4KVxuKTtcbiRtcS1kZWJ1ZzogZmFsc2U7XG4kbXEtcHJpbnQtcHNldWRvLXJ1bGVzOiBmYWxzZTtcbiIsIi8qIHN0eWxlbGludC1kaXNhYmxlIGJsb2NrLWNsb3NpbmctYnJhY2UtZW1wdHktbGluZS1iZWZvcmUsIGF0LXJ1bGUtZW1wdHktbGluZS1iZWZvcmUgKi9cblxuLy9cbi8vICBtwrVcbi8vXG4vLyAgQSBzaW1wbGUgbGlicmFyeSBmb3IgaGFuZGxpbmcgbWVkaWEgcXVlcmllc1xuLy8gIGFuZCBicmVha3BvaW50cyBhY3Jvc3MgU0FTUy9DU1MgYW5kIEphdmFTY3JpcHQuXG4vL1xuLy8gIEBhdXRob3IgRmFiaWFuIE1pY2hhZWwgPGhhbGxvQGZhYmlhbm1pY2hhZWwuZGU+XG4vLyAgQGxpY2Vuc2UgTUlUXG4vL1xuXG4vLyAgRGVmaW5lIHlvdXIgYnJlYWtwb2ludHMgaGVyZS4gTXVzdCBiZSBlaXRoZXIgaW4gcHhcbi8vICBvciBlbSB1bml0cy4gQnJlYWtwb2ludHMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gZW0gYnlcbi8vICB0aGUgbGlicmFyeSBmb3IgYmVzdCBjb25zaXN0ZW5jeSBhY3Jvc3MgZGlmZmVyZW50XG4vLyAgYnJvd3NlcnMuXG4vL1xuLy8gIFJlYWQgW1BYLCBFTSBvciBSRU0gTWVkaWEgUXVlcmllcz9dKGh0dHBzOi8vemVsbHdrLmNvbS9ibG9nL21lZGlhLXF1ZXJ5LXVuaXRzLylcbi8vICBieSBaZWxsIExpZXcgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdW5pdHMgaW4gbWVkaWEgcXVlcmllcy5cbiRtcS1icmVha3BvaW50czogKFxuICAoeHMgNDgwcHggIDQpXG4gIChzbSA3NjhweCAgOClcbiAgKG1kIDEwMjRweCAxMilcbiAgKGxnIDEyODBweCAxMilcbiAgKHhsIDE0NDBweCAxMilcbikgIWRlZmF1bHQ7XG5cbi8vICBQcmludHMgc2VsZWN0b3JzIGZvciBwc2V1ZG8tZWxlbWVudHMsIHdoaWNoIGFyZSB1dGlsaXplZFxuLy8gIGJ5IHRoZSBKYXZhU2NyaXB0IGNvdW50ZXJwYXJ0IG9mIHRoZSBtwrUgbGlicmFyeS4gU2V0IHRvXG4vLyAgZmFsc2UsIGlmIHlvdSBkb27igJl0IG5lZWQgdGhlIEphdmFTY3JpcHQgZnVuY3Rpb25hbGl0eSBvclxuLy8gIHlvdSB3YW50IHRvIGNhbGwgYEBpbmNsdWRlIG1xLXByaW50LXBzZXVkby1ydWxlcygpYFxuLy8gIG1hbnVhbGx5LlxuJG1xLXByaW50LXBzZXVkby1ydWxlczogdHJ1ZSAhZGVmYXVsdDtcblxuLy8gRGVidWcgc2V0dGluZ3NcbiRtcS1kZWJ1ZzogZmFsc2UgIWRlZmF1bHQ7XG4kbXEtZGVidWctei1pbmRleDogMTAwMDAgIWRlZmF1bHQ7XG4kbXEtZGVidWctc2VsZWN0b3I6IFwiYm9keTo6YWZ0ZXJcIiAhZGVmYXVsdDtcblxuLy8gIE1peGluIGZvciBnZW5lcmF0aW5nIGd0ZSBtZWRpYSBxdWVyaWVzXG4vL1xuLy8gIFVzYWdlOlxuLy9cbi8vICBAaW5jbHVkZSBtcShmcm9tIG1kKSB7XG4vLyAgICAubmF2IHtcbi8vICAgICAgcG9zaXRpb246IGZpeGVkO1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgb3I6XG4vL1xuLy8gIC5uYXYge1xuLy8gICAgYmFja2dyb3VuZDogYmx1ZTtcbi8vXG4vLyAgICBAaW5jbHVkZSBtcShmcm9tIHhzIHRvIHNtKSB7XG4vLyAgICAgIGJhY2tncm91bmQ6IHJlZDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy9cbi8vICBTdXBwb3J0ZWQgcXVlcmllczpcbi8vXG4vLyAgQGluY2x1ZGUgbXEobWQpIHsg4oCmIH1cbi8vICBAaW5jbHVkZSBtcShmcm9tIG1kKSB7IOKApiB9IC8vIHNhbWUgYXMgXCJtcShtZClcIlxuLy8gIEBpbmNsdWRlIG1xKHRvIG1kKSB7IOKApiB9XG4vLyAgQGluY2x1ZGUgbXEoZnJvbSB4cyB0byBtZCkgeyDigKYgfVxuLy9cbi8vICBXaXRoIGFkZGl0aW9uYWwgY3VzdG9tIG1lZGlhIHF1ZXJpZXM6XG4vL1xuLy8gIEBpbmNsdWRlIG1xKHhzLCAnKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpJykgeyDigKYgfVxuLy8gIEBpbmNsdWRlIG1xKGZyb20geHMgdG8gbWQsICcob3JpZW50YXRpb246IGxhbmRzY2FwZSknKSB7IOKApiB9XG5AbWl4aW4gbXEoJHF1ZXJ5OiBmYWxzZSwgJGFuZDogZmFsc2UpIHtcblxuICAvLyBJbml0aWFsaXplIHZhcmlhYmxlc1xuICAkbWluLXdpZHRoOiAwO1xuICAkbWF4LXdpZHRoOiAwO1xuICAkbWVkaWEtcXVlcnk6IFwiXCI7XG5cbiAgQGlmICRxdWVyeSB7XG4gICAgLy8gJHF1ZXJ5IGlzIG5vdCBmYWxzZVxuICAgIEBpZiB0eXBlLW9mKCRxdWVyeSkgPT0gbnVtYmVyIHtcbiAgICAgICRtaW4td2lkdGg6ICRxdWVyeTtcbiAgICB9IEBlbHNlIGlmIHR5cGUtb2YoJHF1ZXJ5KSA9PSBsaXN0IHtcbiAgICAgIEBpZiBsZW5ndGgoJHF1ZXJ5KSA9PSA0IGFuZCBudGgoJHF1ZXJ5LCAxKSA9PSBmcm9tIHtcbiAgICAgICAgJG1pbi13aWR0aDogbnRoKCRxdWVyeSwgMik7XG4gICAgICAgICRtYXgtd2lkdGg6IG50aCgkcXVlcnksIDQpO1xuICAgICAgICAvLyBmcm9tIHticmVha3BvaW50fSB0byB7YnJlYWtwb2ludH1cblxuICAgICAgICAkbWluLXdpZHRoOiBtcS1ub3JtYWxpemUtd2lkdGgoJG1pbi13aWR0aCk7XG5cbiAgICAgICAgJGVuZDogbnRoKCRxdWVyeSwgMyk7XG5cbiAgICAgICAgJHN1YnN0cmFjdDogMDtcblxuICAgICAgICBAaWYgJGVuZCA9PSB0byB7XG4gICAgICAgICAgJHN1YnN0cmFjdDogMXB4O1xuICAgICAgICB9IEBlbHNlIGlmICRlbmQgIT0gdGhyb3VnaCB7XG4gICAgICAgICAgQGVycm9yICdXcm9uZyBrZXl3b3JkOiBRdWVyeSBtdXN0IGJlIGluIHRoZSBmb3JtIFwiZnJvbSBbbWluLXdpZHRoL2JyZWFrcG9pbnRdIHRvL3Rocm91Z2ggW21heC13aWR0aC9icmVha3BvaW50XS5cIic7XG4gICAgICAgIH1cblxuICAgICAgICAkbWF4LXdpZHRoOiBtcS1ub3JtYWxpemUtd2lkdGgoJG1heC13aWR0aCkgLSBtcS1ub3JtYWxpemUtd2lkdGgoJHN1YnN0cmFjdCk7XG5cbiAgICAgIH0gQGVsc2UgaWYgbGVuZ3RoKCRxdWVyeSkgPT0gMiB7XG4gICAgICAgIC8vIG9uZSBrZXl3b3JkICsgYnJlYWtwb2ludCBvciBtaW4tL21heC13aWR0aFxuXG4gICAgICAgICRrZXl3b3JkOiBudGgoJHF1ZXJ5LCAxKTtcbiAgICAgICAgJHdpZHRoOiBudGgoJHF1ZXJ5LCAyKTtcblxuICAgICAgICBAaWYgJGtleXdvcmQgPT0gZnJvbSB7XG4gICAgICAgICAgLy8gZnJvbSB7YnJlYWtwb2ludC9taW4td2lkdGh9XG4gICAgICAgICAgJG1pbi13aWR0aDogbXEtbm9ybWFsaXplLXdpZHRoKCR3aWR0aCk7XG5cbiAgICAgICAgfSBAZWxzZSBpZiAka2V5d29yZCA9PSB0byB7XG4gICAgICAgICAgLy8gdG8ge2JyZWFrcG9pbnQvbWF4LXdpZHRofVxuICAgICAgICAgICRtYXgtd2lkdGg6IG1xLW5vcm1hbGl6ZS13aWR0aCgkd2lkdGgpIC0gbXEtbm9ybWFsaXplLXdpZHRoKDFweCk7XG5cbiAgICAgICAgfSBAZWxzZSBpZiAka2V5d29yZCA9PSB0aHJvdWdoIHtcbiAgICAgICAgICAvLyB0aHJvdWdoIHtiZWFrcG9pbnQvbWF4LXdpZHRofVxuICAgICAgICAgICRtYXgtd2lkdGg6IG1xLW5vcm1hbGl6ZS13aWR0aCgkd2lkdGgpO1xuXG4gICAgICAgIH0gQGVsc2UgaWYgJGtleXdvcmQgPT0gb25seSB7XG4gICAgICAgICAgLy8gb25seSB7YnJlYWtwb2ludH1cblxuICAgICAgICAgICRpdGVtcy1sZW5ndGg6IGxlbmd0aCgkbXEtYnJlYWtwb2ludHMpO1xuICAgICAgICAgICRuZXh0LWJyZWFrcG9pbnQ6IGZhbHNlO1xuXG4gICAgICAgICAgQGZvciAkaSBmcm9tIDEgdGhyb3VnaCAkaXRlbXMtbGVuZ3RoIHtcbiAgICAgICAgICAgICRpdGVtOiAgICAgIG50aCgkbXEtYnJlYWtwb2ludHMsICRpKTtcbiAgICAgICAgICAgICRpdGVtLW5hbWU6IG50aCgkaXRlbSwgMSk7XG5cbiAgICAgICAgICAgIEBpZiAkbmV4dC1icmVha3BvaW50ID09IHRydWUge1xuICAgICAgICAgICAgICAvLyBicmVha3BvaW50IHdhcyBmb3VuZCBpbiBsYXN0IGl0ZXJhdGlvblxuICAgICAgICAgICAgICAkbmV4dC1icmVha3BvaW50OiAkaXRlbS1uYW1lO1xuICAgICAgICAgICAgfSBAZWxzZSBpZiAkd2lkdGggPT0gJGl0ZW0tbmFtZSB7XG4gICAgICAgICAgICAgIC8vIGJyZWFrcG9pbnQgZm91bmQsIHdpbGwgYmUgYXNzaWduZWQgaW4gbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgJG5leHQtYnJlYWtwb2ludDogdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkbWluLXdpZHRoOiBtcS1ub3JtYWxpemUtd2lkdGgoJHdpZHRoKTtcblxuICAgICAgICAgIEBpZiB0eXBlLW9mKCRuZXh0LWJyZWFrcG9pbnQpICE9IGJvb2wge1xuICAgICAgICAgICAgJG1heC13aWR0aDogbXEtbm9ybWFsaXplLXdpZHRoKCRuZXh0LWJyZWFrcG9pbnQpIC0gbXEtbm9ybWFsaXplLXdpZHRoKDFweCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gQGVsc2Uge1xuICAgICAgICAgIEBlcnJvciBcIkludmFsaWQgYnJlYWtwb2ludCBxdWVyeSBzdXBwbGllZCB0byBtcSgpXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IEBlbHNlIHtcbiAgICAgIC8vIHticmVha3BvaW50fSA9PiBmcm9tIHticmVha3BvaW50fVxuICAgICAgJG1pbi13aWR0aDogbXEtbm9ybWFsaXplLXdpZHRoKCRxdWVyeSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnVpbGQgTWVkaWEgUXVlcnlcblxuICBAaWYgJG1pbi13aWR0aCAhPSAwIHtcbiAgICAkbWVkaWEtcXVlcnk6IFwiKG1pbi13aWR0aDogI3skbWluLXdpZHRofSlcIjtcbiAgfVxuXG4gIEBpZiAkbWF4LXdpZHRoICE9IDAge1xuICAgIEBpZiAkbWVkaWEtcXVlcnkgIT0gXCJcIiB7XG4gICAgICAkbWVkaWEtcXVlcnk6IFwiI3skbWVkaWEtcXVlcnl9IGFuZCBcIjtcbiAgICB9XG4gICAgJG1lZGlhLXF1ZXJ5OiBcIiN7JG1lZGlhLXF1ZXJ5fSAobWF4LXdpZHRoOiAjeyRtYXgtd2lkdGh9KVwiO1xuICB9XG5cbiAgQGlmICRhbmQge1xuICAgICRtZWRpYS1xdWVyeTogXCIjeyRtZWRpYS1xdWVyeX0gYW5kICN7JGFuZH1cIjtcbiAgfVxuXG4gICRtZWRpYS1xdWVyeTogdW5xdW90ZSgjeyRtZWRpYS1xdWVyeX0pO1xuXG4gIEBpZiAkbWVkaWEtcXVlcnkgIT0gXCJcIiB7XG4gICAgLy8gT25seSBwcmludCBhIG1lZGlhIHF1ZXJ5IGlmIGl04oCZcyBub3QgZW1wdHlcbiAgICBAbWVkaWEgI3skbWVkaWEtcXVlcnl9IHtcbiAgICAgIEBjb250ZW50O1xuICAgIH1cbiAgfSBAZWxzZSB7XG4gICAgQGNvbnRlbnQ7XG4gIH1cbn1cblxuQGZ1bmN0aW9uIG1xLW5vcm1hbGl6ZS13aWR0aCgkd2lkdGgpIHtcblxuICAkdHlwZTogdHlwZS1vZigkd2lkdGgpO1xuXG4gIEBpZiAkdHlwZSA9PSBzdHJpbmcge1xuICAgIC8vIGJyZWFrcG9pbnQgbmFtZVxuICAgIEByZXR1cm4gbXEtbm9ybWFsaXplLXdpZHRoKG1xLXJldHJpZXZlLWJyZWFrcG9pbnQtd2lkdGgoJHdpZHRoKSk7XG4gIH0gQGVsc2UgaWYgJHR5cGUgPT0gbnVtYmVyIHtcbiAgICAvLyBudW1lcmljIHdpZHRoXG5cbiAgICAkdW5pdDogdW5xdW90ZSh1bml0KCR3aWR0aCkpO1xuXG4gICAgQGlmIG1xLXN0cmlwLXVuaXQoJHdpZHRoKSA9PSAwIHtcbiAgICAgIEByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBAaWYgJHVuaXQgPT0gcHgge1xuICAgICAgQHJldHVybiAkd2lkdGggLyAxNnB4ICogMWVtO1xuICAgIH0gQGVsc2UgaWYgJHVuaXQgPT0gZW0ge1xuICAgICAgQHJldHVybiAkd2lkdGg7XG4gICAgfSBAZWxzZSBpZiAkdW5pdCA9PSByZW0ge1xuICAgICAgQHJldHVybiAkd2lkdGggLyAxcmVtICogMWVtO1xuICAgIH0gQGVsc2Uge1xuICAgICAgQGVycm9yIFwiVW5pdCBtdXN0IGJlIGEgcHggb3IgZW0gdmFsdWVcIjtcbiAgICB9XG4gIH0gQGVsc2Uge1xuICAgIEBlcnJvciBcIkludmFsaWQgd2lkdGggcGFyYW1ldGVyXCI7XG4gIH1cbn1cblxuLy8gIENvbnZlcnRzIGEgcGl4ZWwgdmFsdWUgdG8gaXTigJlzIGVtIGVxdWl2YWxlbnQsIGJhc2VkIG9uXG4vLyAgdGhlIGJyb3dzZXLigJlzIGFzc3VtZWQgZGVmYXVsdCBmb250LXNpemUgb2YgMTZweC4gQXMgbWVkaWFcbi8vICBxdWVyaWVzIGlnbm9yZSBmb250LXNpemVzIHNldCB2aWEgQ1NTLCB0aGlzIGZ1bmN0aW9uIGRvZXNcbi8vICBub3QgYW4gYWRkaXRpb25hbCBcImJhc2UgZm9udCBzaXplXCIgdG8gYmUgc2V0LlxuLy9cbi8vICBAcmV0dXJuIFRoZSBlbSBlcXVpdmFsZW50IG9mIGdpdmVuIHBpeGVsIHZhbHVlLlxuQGZ1bmN0aW9uIG1xLXB4MmVtKCRweCkge1xuXG4gIEBpZiB0eXBlLW9mKCRweCkgIT0gbnVtYmVyIHtcbiAgICBAZXJyb3IgXCJtcS1weDJlbSgpIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuXCI7XG4gICAgQHJldHVybiAwO1xuICB9XG5cbiAgQGlmICh1bml0bGVzcygkcHgpKSB7XG4gICAgQHdhcm4gXCJBc3N1bWluZyAjeyRweH0gdG8gYmUgaW4gcGl4ZWxzLCBhdHRlbXB0aW5nIHRvIGNvbnZlcnQgaXQgaW50byBwaXhlbHMgZm9yIHlvdVwiOyAvLyBzYXNzLWxpbnQ6ZGlzYWJsZS1saW5lIG5vLXdhcm5cbiAgICBAcmV0dXJuIG1xLXB4MmVtKCRweCArIDApOyAvLyBUaGF0IG1heSBmYWlsLlxuICB9IEBlbHNlIGlmICh1bml0KCRweCkgPT0gZW0pIHtcbiAgICBAcmV0dXJuICRweDtcbiAgfVxuICBAcmV0dXJuICgkcHggLyAxNnB4KSAqIDFlbTtcbn1cblxuLy8vIFJlbW92ZSB0aGUgdW5pdCBvZiBhIGxlbmd0aFxuLy8vIFNvdXJjZTogaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9zbmlwcGV0cy9zYXNzL3N0cmlwLXVuaXQtZnVuY3Rpb24vXG4vLy8gQHBhcmFtIHtOdW1iZXJ9ICRudW1iZXIgLSBOdW1iZXIgdG8gcmVtb3ZlIHVuaXQgZnJvbVxuLy8vIEByZXR1cm4ge051bWJlcn0gLSBVbml0bGVzcyBudW1iZXJcbkBmdW5jdGlvbiBtcS1zdHJpcC11bml0KCRudW1iZXIpIHtcbiAgQGlmIHR5cGUtb2YoJG51bWJlcikgPT0gXCJudW1iZXJcIiBhbmQgbm90IHVuaXRsZXNzKCRudW1iZXIpIHtcbiAgICBAcmV0dXJuICRudW1iZXIgLyAoJG51bWJlciAqIDAgKyAxKTtcbiAgfVxuXG4gIEByZXR1cm4gJG51bWJlcjtcbn1cblxuLy8gUmV0cmlldmVzIHRoZSBtaW4td2lkdGggb2YgYSBicmVha3BvaW50IGluIHB4LCBhc3N1bWluZ1xuLy8gYSBmb250LXNpemUgb2YgMTZweC5cbi8vXG4vLyBAcmV0dXJuIFRoZSBtaW4td2lkdGggb2YgYSBicmVha3BvaW50IGluIHBpeGVsc1xuQGZ1bmN0aW9uIG1xLXJldHJpZXZlLWJyZWFrcG9pbnQtd2lkdGgoJG5hbWUpIHtcbiAgQGVhY2ggJGJyZWFrcG9pbnQgaW4gJG1xLWJyZWFrcG9pbnRzIHtcbiAgICAkYnJlYWtwb2ludC1uYW1lOiAgbnRoKCRicmVha3BvaW50LCAxKTtcbiAgICAkYnJlYWtwb2ludC13aWR0aDogbnRoKCRicmVha3BvaW50LCAyKTtcblxuICAgIEBpZiAkbmFtZSA9PSAkYnJlYWtwb2ludC1uYW1lIHtcbiAgICAgIEBpZiB1bml0KCRicmVha3BvaW50LXdpZHRoKSA9PSBlbSB7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gcHggdmFsdWUsIGlmIGJyZWFrcG9pbnRzIHdoZXJlIGRlZmluZWRcbiAgICAgICAgLy8gaW4gZW1cbiAgICAgICAgJGJyZWFrcG9pbnQtd2lkdGg6ICRicmVha3BvaW50LXdpZHRoIC8gMTZweDtcbiAgICAgIH1cbiAgICAgIEByZXR1cm4gJGJyZWFrcG9pbnQtd2lkdGg7XG4gICAgfVxuICB9XG4gIEByZXR1cm4gXCJCcmVha3BvaW50ICN7JG5hbWV9IGRvZXMgbm90IGV4aXN0XCI7XG59XG5cbi8vIFByaW50cyB0aGUgcHNldWRvLXJ1bGUocykgbmVlZGVkIGJ5IHRoZSBKUyBjb3VudGVycGFydFxuLy8gb2YgbcK1LlxuQG1peGluIG1xLXByaW50LXBzZXVkby1ydWxlcyB7XG5cbiAgJGJyZWFrcG9pbnQtbmFtZXM6IFwiXCI7XG5cbiAgQGVhY2ggJGJyZWFrcG9pbnQgaW4gJG1xLWJyZWFrcG9pbnRzIHtcbiAgICAkYnJlYWtwb2ludC1uYW1lOiBudGgoJGJyZWFrcG9pbnQsIDEpO1xuICAgICRicmVha3BvaW50LXdpZHRoOiBudGgoJGJyZWFrcG9pbnQsIDIpO1xuICAgICRhZGQ6ICcgXCIjeyRicmVha3BvaW50LW5hbWV9XCI6IFwiKG1pbi13aWR0aDogI3ttcS1ub3JtYWxpemUtd2lkdGgoJGJyZWFrcG9pbnQtd2lkdGgpfSlcIiAnO1xuICAgIEBpZiAkYnJlYWtwb2ludC1uYW1lcyAhPSBcIlwiIHtcbiAgICAgICRicmVha3BvaW50LW5hbWVzOiBcIiN7JGJyZWFrcG9pbnQtbmFtZXN9LCN7JGFkZH1cIjtcbiAgICB9IEBlbHNlIHtcbiAgICAgICRicmVha3BvaW50LW5hbWVzOiAkYWRkO1xuICAgIH1cbiAgfVxuXG4gICRicmVha3BvaW50LW5hbWVzOiBcIntcIiArICRicmVha3BvaW50LW5hbWVzICsgXCJ9XCI7XG5cbiAgaHRtbDo6YmVmb3JlIHtcbiAgICAvKiBBdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBtcSB0byBiZSBjb25zdW1lZCBieSBpdHMgSmF2YVNjcmlwdCBjb3VudGVycGFydCAqL1xuICAgIGNvbnRlbnQ6ICRicmVha3BvaW50LW5hbWVzO1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cbn1cblxuQGlmICRtcS1wcmludC1wc2V1ZG8tcnVsZXMge1xuICAvLyBQcmludCBwc2V1ZG8tcnVsZXMsIGlmIGVuYWJsZWRcbiAgQGluY2x1ZGUgbXEtcHJpbnQtcHNldWRvLXJ1bGVzO1xufVxuXG5AbWl4aW4gbXEtZGVidWcge1xuICAvLyBQcmludCBkZWJ1ZyBydWxlcywgaWYgZW5hYmxlZFxuICAje3VucXVvdGUoJG1xLWRlYnVnLXNlbGVjdG9yKX0ge1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgLjc1KTtcbiAgICBib3R0b206IDA7XG4gICAgY29sb3I6ICNmZmY7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcbiAgICBmb250LXNpemU6IDEwcHg7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gICAgcGFkZGluZzogM3B4IDZweDtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgcmlnaHQ6IDA7XG4gICAgei1pbmRleDogJG1xLWRlYnVnLXotaW5kZXg7XG4gIH1cblxuICBAZWFjaCAkYnJlYWtwb2ludCBpbiAkbXEtYnJlYWtwb2ludHMge1xuICAgICRicmVha3BvaW50LW5hbWU6ICBudGgoJGJyZWFrcG9pbnQsIDEpO1xuICAgICRicmVha3BvaW50LXdpZHRoOiBudGgoJGJyZWFrcG9pbnQsIDIpO1xuXG4gICAgQGluY2x1ZGUgbXEoJGJyZWFrcG9pbnQtbmFtZSkge1xuICAgICAgI3t1bnF1b3RlKCRtcS1kZWJ1Zy1zZWxlY3Rvcil9IHtcbiAgICAgICAgY29udGVudDogXCJCcmVha3BvaW50OiAjeyRicmVha3BvaW50LW5hbWV9ICg+PSAjeyRicmVha3BvaW50LXdpZHRofSkgfCBUZW1wbGF0ZTogXCIgYXR0cihkYXRhLXRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBAbWVkaWEgcHJpbnQge1xuICAgICN7dW5xdW90ZSgkbXEtZGVidWctc2VsZWN0b3IpfSB7XG4gICAgICBjb250ZW50OiBcIlwiICFpbXBvcnRhbnQ7XG4gICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgfVxuICB9XG59XG5cbkBtaXhpbiBtcS1kcGkoJGRwaTogMikge1xuXG4gIEBpZiAoJGRwaSAhPSAxKSB7XG4gICAgQG1lZGlhICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86ICN7JGRwaX0pLCAobWluLXJlc29sdXRpb246ICN7JGRwaSAqIDk2ZHBpfSkge1xuICAgICAgQGNvbnRlbnQ7XG4gICAgfVxuICB9IEBlbHNlIHtcbiAgICBAY29udGVudDtcbiAgfVxufVxuIiwiLyogc3R5bGVsaW50LWRpc2FibGUgYXQtcnVsZS1lbXB0eS1saW5lLWJlZm9yZSAqL1xuXG5AZnVuY3Rpb24gcmVtKCRweCkge1xuICBAcmV0dXJuICgkcHggLyAxNnB4ICogMXJlbSk7XG59XG5cbkBmdW5jdGlvbiBlbSgkcHgsICRiYXNlOiAxNnB4KSB7XG4gIEByZXR1cm4gJHB4IC8gJGJhc2UgKiAxZW07XG59XG4iLCIvKiBzdHlsZWxpbnQtZGlzYWJsZSBhdC1ydWxlLWVtcHR5LWxpbmUtYmVmb3JlICovXG5cbkBtaXhpbiBsaW5rLWJhY2twbGFuZSgkb2Zmc2V0OiA1cHgsICRiYWNrZ3JvdW5kOiBsaWdodCkge1xuXG4gICRiYWNrcGxhbmUtY29sb3I6IG51bGw7XG4gICRiYWNrcGxhbmUtaG92ZXItb3BhY2l0eTpudWxsO1xuXG4gIEBpZiAkYmFja2dyb3VuZCA9PSBsaWdodCB7XG4gICAgJGJhY2twbGFuZS1jb2xvcjogICAgICAgICAgJGNvbG9yLWJsYWNrO1xuICAgICRiYWNrcGxhbmUtaG92ZXItb3BhY2l0eTogIC4wNDtcbiAgfVxuXG4gIEBlbHNlIGlmICRiYWNrZ3JvdW5kID09IGRhcmsge1xuICAgICRiYWNrcGxhbmUtY29sb3I6ICAgICAgICAgICRjb2xvci13aGl0ZTtcbiAgICAkYmFja3BsYW5lLWhvdmVyLW9wYWNpdHk6ICAuMTI7XG4gIH1cblxuICBAZWxzZSB7XG4gICAgQGVycm9yIFwiTGluayBCYWNrcGxhbmXigJlzICRiYWNrZ3JvdW5kIHBhcmFtZXRlciBtdXN0IGJlIGVpdGhlciBgbGlnaHRgIG9yIGBkYXJrYC5cIjtcbiAgfVxuXG4gIG91dGxpbmU6IDA7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgei1pbmRleDogMDtcblxuICAmOjpiZWZvcmUge1xuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgIGJvcmRlci1yYWRpdXM6ICRib3JkZXItcmFkaXVzLWxpbmstYmFja3BsYW5lO1xuICAgIGJvdHRvbTogMDtcbiAgICBjb250ZW50OiBcIlwiO1xuICAgIGxlZnQ6IDA7XG4gICAgbWFyZ2luOiAoLTEgKiAkb2Zmc2V0KTtcbiAgICBvdXRsaW5lOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgb3V0bGluZS1vZmZzZXQ6IDJweDtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcmlnaHQ6IDA7XG4gICAgdG9wOiAwO1xuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQgLjJzO1xuICAgIHotaW5kZXg6IC0xO1xuICB9XG5cbiAgJjpob3Zlcjo6YmVmb3JlIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKCRiYWNrcGxhbmUtY29sb3IsICRiYWNrcGxhbmUtaG92ZXItb3BhY2l0eSk7XG4gIH1cblxuICBib2R5Om5vdCguanMtZm9jdXMtdmlzaWJsZSkgJjpmb2N1czo6YmVmb3JlIHtcbiAgICBvdXRsaW5lLWNvbG9yOiAkY29sb3ItZm9jdXMtb3V0bGluZTtcbiAgfVxuXG4gICYuZm9jdXMtdmlzaWJsZTo6YmVmb3JlIHtcbiAgICBvdXRsaW5lLWNvbG9yOiAkY29sb3ItZm9jdXMtb3V0bGluZTtcbiAgfVxuXG4gIC5qcy1mb2N1cy12aXNpYmxlICY6Zm9jdXM6bm90KC5mb2N1cy12aXNpYmxlKSB7XG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgZm9jdXMgb3V0bGluZSB3aGVuIEVsZW1lbnQgaXMgY2xpY2tlZCBieSBtb3VzZS5cbiAgICAgKi9cbiAgICBvdXRsaW5lLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgfVxufVxuXG5AbWl4aW4gZGFyay1iYWNrZ3JvdW5kIHtcbiAgLi1iYWNrZ3JvdW5kXFw6ZGFyayAmIHtcbiAgICBAY29udGVudDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUdBQSx3RkFBd0Y7QUNBeEYsaURBQWlEO0FDQWpELGlEQUFpRDtBTEdqRCxBQUFBLFdBQVcsQ0FBQztFQUNWLE9BQU8sRUFBRSxJQUFJO0VBQ2IsU0FBUyxFQUFFLElBQUk7RUFDZixXQUFXLEVBQUUsS0FBSztDQUNuQjs7QUFFRCxBQUFBLFdBQVcsR0FBRyxDQUFDLENBQUM7RUFDZCxhQUFhLEVBQUUsTUFBTTtFQUNyQixZQUFZLEVBQUUsSUFBSTtFQUNsQixLQUFLLEVBQUUsSUFBSTtDQVNaOztBRzJKRyxNQUFNLEVBQUUsU0FBUyxFQUFFLElBQUk7RUh2SzNCLEFBQUEsV0FBVyxHQUFHLENBQUMsQ0FBQztJQU1aLEtBQUssRUFBRSxHQUFHO0dBTWI7OztBRzJKRyxNQUFNLEVBQUUsU0FBUyxFQUFFLElBQUk7RUh2SzNCLEFBQUEsV0FBVyxHQUFHLENBQUMsQ0FBQztJQVVaLEtBQUssRUFBRSxjQUFpQjtHQUUzQjs7O0FBRUQsQUFBQSxXQUFXLENBQUMsR0FBRyxBQUFBLE9BQU8sQ0FBQztFQUNyQixLQUFLLEVFZW9CLE9BQWtCO0VGZDNDLE9BQU8sRUFBRSxJQUFJO0VBQ2IsV0FBVyxFQUFFLE1BQU07Q0FDcEI7O0FBRUQsQUFBQSxXQUFXLENBQUMsR0FBRyxDQUFDO0VBQ2QsY0FBYyxFQUFFLENBQUM7RUFDakIsY0FBYyxFQUFFLElBQUk7Q0FDckI7O0FBRUQsQUFBQSxXQUFXLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQztFQUMxQixNQUFNLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0VmUSxPQUFPO0VGZ0JoQyxPQUFPLEVBQUUsR0FBRztDQUNiIn0= */\n\n\n// WEBPACK FOOTER //\n// ./src/scss/templates/cases.scss","/* stylelint-disable block-closing-brace-empty-line-before, at-rule-empty-line-before */\n\n//\n//  mÂµ\n//\n//  A simple library for handling media queries\n//  and breakpoints across SASS/CSS and JavaScript.\n//\n//  @author Fabian Michael <hallo@fabianmichael.de>\n//  @license MIT\n//\n\n//  Define your breakpoints here. Must be either in px\n//  or em units. Breakpoints will be converted to em by\n//  the library for best consistency across different\n//  browsers.\n//\n//  Read [PX, EM or REM Media Queries?](https://zellwk.com/blog/media-query-units/)\n//  by Zell Liew for more information on units in media queries.\n$mq-breakpoints: (\n  (xs 480px  4)\n  (sm 768px  8)\n  (md 1024px 12)\n  (lg 1280px 12)\n  (xl 1440px 12)\n) !default;\n\n//  Prints selectors for pseudo-elements, which are utilized\n//  by the JavaScript counterpart of the mÂµ library. Set to\n//  false, if you donât need the JavaScript functionality or\n//  you want to call `@include mq-print-pseudo-rules()`\n//  manually.\n$mq-print-pseudo-rules: true !default;\n\n// Debug settings\n$mq-debug: false !default;\n$mq-debug-z-index: 10000 !default;\n$mq-debug-selector: \"body::after\" !default;\n\n//  Mixin for generating gte media queries\n//\n//  Usage:\n//\n//  @include mq(from md) {\n//    .nav {\n//      position: fixed;\n//    }\n//  }\n//\n//  or:\n//\n//  .nav {\n//    background: blue;\n//\n//    @include mq(from xs to sm) {\n//      background: red;\n//    }\n//  }\n//\n//\n//  Supported queries:\n//\n//  @include mq(md) { â¦ }\n//  @include mq(from md) { â¦ } // same as \"mq(md)\"\n//  @include mq(to md) { â¦ }\n//  @include mq(from xs to md) { â¦ }\n//\n//  With additional custom media queries:\n//\n//  @include mq(xs, '(orientation: landscape)') { â¦ }\n//  @include mq(from xs to md, '(orientation: landscape)') { â¦ }\n@mixin mq($query: false, $and: false) {\n\n  // Initialize variables\n  $min-width: 0;\n  $max-width: 0;\n  $media-query: \"\";\n\n  @if $query {\n    // $query is not false\n    @if type-of($query) == number {\n      $min-width: $query;\n    } @else if type-of($query) == list {\n      @if length($query) == 4 and nth($query, 1) == from {\n        $min-width: nth($query, 2);\n        $max-width: nth($query, 4);\n        // from {breakpoint} to {breakpoint}\n\n        $min-width: mq-normalize-width($min-width);\n\n        $end: nth($query, 3);\n\n        $substract: 0;\n\n        @if $end == to {\n          $substract: 1px;\n        } @else if $end != through {\n          @error 'Wrong keyword: Query must be in the form \"from [min-width/breakpoint] to/through [max-width/breakpoint].\"';\n        }\n\n        $max-width: mq-normalize-width($max-width) - mq-normalize-width($substract);\n\n      } @else if length($query) == 2 {\n        // one keyword + breakpoint or min-/max-width\n\n        $keyword: nth($query, 1);\n        $width: nth($query, 2);\n\n        @if $keyword == from {\n          // from {breakpoint/min-width}\n          $min-width: mq-normalize-width($width);\n\n        } @else if $keyword == to {\n          // to {breakpoint/max-width}\n          $max-width: mq-normalize-width($width) - mq-normalize-width(1px);\n\n        } @else if $keyword == through {\n          // through {beakpoint/max-width}\n          $max-width: mq-normalize-width($width);\n\n        } @else if $keyword == only {\n          // only {breakpoint}\n\n          $items-length: length($mq-breakpoints);\n          $next-breakpoint: false;\n\n          @for $i from 1 through $items-length {\n            $item:      nth($mq-breakpoints, $i);\n            $item-name: nth($item, 1);\n\n            @if $next-breakpoint == true {\n              // breakpoint was found in last iteration\n              $next-breakpoint: $item-name;\n            } @else if $width == $item-name {\n              // breakpoint found, will be assigned in next iteration\n              $next-breakpoint: true;\n            }\n          }\n\n          $min-width: mq-normalize-width($width);\n\n          @if type-of($next-breakpoint) != bool {\n            $max-width: mq-normalize-width($next-breakpoint) - mq-normalize-width(1px);\n          }\n\n        } @else {\n          @error \"Invalid breakpoint query supplied to mq()\";\n        }\n      }\n    } @else {\n      // {breakpoint} => from {breakpoint}\n      $min-width: mq-normalize-width($query);\n    }\n  }\n\n  // Build Media Query\n\n  @if $min-width != 0 {\n    $media-query: \"(min-width: #{$min-width})\";\n  }\n\n  @if $max-width != 0 {\n    @if $media-query != \"\" {\n      $media-query: \"#{$media-query} and \";\n    }\n    $media-query: \"#{$media-query} (max-width: #{$max-width})\";\n  }\n\n  @if $and {\n    $media-query: \"#{$media-query} and #{$and}\";\n  }\n\n  $media-query: unquote(#{$media-query});\n\n  @if $media-query != \"\" {\n    // Only print a media query if itâs not empty\n    @media #{$media-query} {\n      @content;\n    }\n  } @else {\n    @content;\n  }\n}\n\n@function mq-normalize-width($width) {\n\n  $type: type-of($width);\n\n  @if $type == string {\n    // breakpoint name\n    @return mq-normalize-width(mq-retrieve-breakpoint-width($width));\n  } @else if $type == number {\n    // numeric width\n\n    $unit: unquote(unit($width));\n\n    @if mq-strip-unit($width) == 0 {\n      @return 0;\n    }\n\n    @if $unit == px {\n      @return $width / 16px * 1em;\n    } @else if $unit == em {\n      @return $width;\n    } @else if $unit == rem {\n      @return $width / 1rem * 1em;\n    } @else {\n      @error \"Unit must be a px or em value\";\n    }\n  } @else {\n    @error \"Invalid width parameter\";\n  }\n}\n\n//  Converts a pixel value to itâs em equivalent, based on\n//  the browserâs assumed default font-size of 16px. As media\n//  queries ignore font-sizes set via CSS, this function does\n//  not an additional \"base font size\" to be set.\n//\n//  @return The em equivalent of given pixel value.\n@function mq-px2em($px) {\n\n  @if type-of($px) != number {\n    @error \"mq-px2em() value must be a number.\";\n    @return 0;\n  }\n\n  @if (unitless($px)) {\n    @warn \"Assuming #{$px} to be in pixels, attempting to convert it into pixels for you\"; // sass-lint:disable-line no-warn\n    @return mq-px2em($px + 0); // That may fail.\n  } @else if (unit($px) == em) {\n    @return $px;\n  }\n  @return ($px / 16px) * 1em;\n}\n\n/// Remove the unit of a length\n/// Source: https://css-tricks.com/snippets/sass/strip-unit-function/\n/// @param {Number} $number - Number to remove unit from\n/// @return {Number} - Unitless number\n@function mq-strip-unit($number) {\n  @if type-of($number) == \"number\" and not unitless($number) {\n    @return $number / ($number * 0 + 1);\n  }\n\n  @return $number;\n}\n\n// Retrieves the min-width of a breakpoint in px, assuming\n// a font-size of 16px.\n//\n// @return The min-width of a breakpoint in pixels\n@function mq-retrieve-breakpoint-width($name) {\n  @each $breakpoint in $mq-breakpoints {\n    $breakpoint-name:  nth($breakpoint, 1);\n    $breakpoint-width: nth($breakpoint, 2);\n\n    @if $name == $breakpoint-name {\n      @if unit($breakpoint-width) == em {\n        // Convert to px value, if breakpoints where defined\n        // in em\n        $breakpoint-width: $breakpoint-width / 16px;\n      }\n      @return $breakpoint-width;\n    }\n  }\n  @return \"Breakpoint #{$name} does not exist\";\n}\n\n// Prints the pseudo-rule(s) needed by the JS counterpart\n// of mÂµ.\n@mixin mq-print-pseudo-rules {\n\n  $breakpoint-names: \"\";\n\n  @each $breakpoint in $mq-breakpoints {\n    $breakpoint-name: nth($breakpoint, 1);\n    $breakpoint-width: nth($breakpoint, 2);\n    $add: ' \"#{$breakpoint-name}\": \"(min-width: #{mq-normalize-width($breakpoint-width)})\" ';\n    @if $breakpoint-names != \"\" {\n      $breakpoint-names: \"#{$breakpoint-names},#{$add}\";\n    } @else {\n      $breakpoint-names: $add;\n    }\n  }\n\n  $breakpoint-names: \"{\" + $breakpoint-names + \"}\";\n\n  html::before {\n    /* Automatically generated by mq to be consumed by its JavaScript counterpart */\n    content: $breakpoint-names;\n    display: none;\n  }\n}\n\n@if $mq-print-pseudo-rules {\n  // Print pseudo-rules, if enabled\n  @include mq-print-pseudo-rules;\n}\n\n@mixin mq-debug {\n  // Print debug rules, if enabled\n  #{unquote($mq-debug-selector)} {\n    background: rgba(0, 0, 0, .75);\n    bottom: 0;\n    color: #fff;\n    display: block;\n    font-family: monospace;\n    font-size: 10px;\n    line-height: 1;\n    padding: 3px 6px;\n    position: fixed;\n    right: 0;\n    z-index: $mq-debug-z-index;\n  }\n\n  @each $breakpoint in $mq-breakpoints {\n    $breakpoint-name:  nth($breakpoint, 1);\n    $breakpoint-width: nth($breakpoint, 2);\n\n    @include mq($breakpoint-name) {\n      #{unquote($mq-debug-selector)} {\n        content: \"Breakpoint: #{$breakpoint-name} (>= #{$breakpoint-width}) | Template: \" attr(data-template);\n      }\n    }\n  }\n\n  @media print {\n    #{unquote($mq-debug-selector)} {\n      content: \"\" !important;\n      display: none !important;\n    }\n  }\n}\n\n@mixin mq-dpi($dpi: 2) {\n\n  @if ($dpi != 1) {\n    @media (-webkit-min-device-pixel-ratio: #{$dpi}), (min-resolution: #{$dpi * 96dpi}) {\n      @content;\n    }\n  } @else {\n    @content;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/scss/templates/src/scss/tools/mq.scss"],"sourceRoot":""}